/* -*- coding: utf-8 -*-
 * ----------------------------------------------------------------------
 * Copyright Â© 2012, RedJack, LLC.
 * All rights reserved.
 *
 * Please see the LICENSE.txt file in this distribution for license
 * details.
 * ----------------------------------------------------------------------
 */

#include <assert.h>

#include <libcork/core.h>
#include <libcork/helpers/gc.h>

#include "swanson/kernel.h"
#include "swanson/metamodel.h"


/*-----------------------------------------------------------------------
 * Dynamic opsets
 */

struct swan_explicit_opset {
    struct swan_opset  parent;
    struct swan_opset  *base;
    size_t  instance_size;
    struct swan_operation  alloc;
    struct swan_operation  unref;
};

_evaluate_(swan_explicit, alloc)
{
    struct swan_explicit_opset  *e_opset =
        cork_container_of(operation, struct swan_explicit_opset, alloc);
    assert(param_count == 1);
    assert(swan_value_is_empty(&params[0]));
    params[0].content = cork_calloc(1, e_opset->instance_size);
    params[0].opset = swan_opset_alias(e_opset->base);
    return 0;
}

_evaluate_(swan_explicit, unref)
{
    assert(param_count == 1);
    free(params[0].content);
    swan_opset_unref(params[0].opset);
    swan_value_clear(&params[0]);
    return 0;
}

_get_operation_(swan_explicit)
{
    struct swan_explicit_opset  *e_opset =
        cork_container_of(opset, struct swan_explicit_opset, parent);

    if (strcmp(op_name, "~alloc") == 0) {
        return &e_opset->alloc;
    } else if (strcmp(op_name, "~unref") == 0) {
        return &e_opset->unref;
    } else {
        return swan_opset_get_operation(e_opset->base, op_name);
    }
}

static struct swan_opset *
swan_explicit__alias(struct swan_opset *opset)
{
    struct swan_explicit_opset  *e_opset =
        cork_container_of(opset, struct swan_explicit_opset, parent);
    return cork_gc_incref(e_opset);
}

static void
swan_explicit__unref(struct swan_opset *opset)
{
    struct swan_explicit_opset  *e_opset =
        cork_container_of(opset, struct swan_explicit_opset, parent);
    cork_gc_decref(e_opset);
}

_free_(swan_explicit_opset) {
    struct swan_explicit_opset  *e_opset = obj;
    swan_opset_unref(e_opset->base);
}

_gc_no_recurse_(swan_explicit_opset);

struct swan_opset *
swan_explicit_opset_new_from_size(struct swan_opset *base, size_t instance_size)
{
    struct swan_explicit_opset  *e_opset = cork_gc_new(swan_explicit_opset);
    e_opset->parent.get_operation = swan_explicit__get_operation;
    e_opset->parent.alias = swan_explicit__alias;
    e_opset->parent.unref = swan_explicit__unref;
    e_opset->base = base;
    e_opset->instance_size = instance_size;
    e_opset->alloc.evaluate = eval_func(swan_explicit, alloc);
    e_opset->unref.evaluate = eval_func(swan_explicit, unref);
    return &e_opset->parent;
}

struct swan_opset *
swan_explicit_opset_new(struct swan_opset *base)
{
    /* TODO: Call an operation to get the instance_size, then delegate to
     * new_from_size */
    return NULL;
}


/*-----------------------------------------------------------------------
 * Helper macros
 */

#define _declare_explicit_opset_(name) \
static struct swan_explicit_opset  _##name##__opset;

#define _explicit_opset_(name, base, instance_size) \
static struct swan_explicit_opset  _##name##__opset = { \
    { \
        swan_explicit__get_operation, \
        swan_opset__static__alias, \
        swan_opset__static__unref \
    }, \
    base, \
    instance_size, \
    { eval_func(swan_explicit, alloc) }, \
    { eval_func(swan_explicit, unref) } \
};

#define explicit_opset(name)  (&_##name##__opset.parent)

#define _public_explicit_opset_(name, base, instance_size) \
_explicit_opset_(name, base, instance_size); \
_opset_accessor_(name, explicit_opset(name));
