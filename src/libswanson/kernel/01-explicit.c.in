/* -*- coding: utf-8 -*-
 * ----------------------------------------------------------------------
 * Copyright Â© 2012, RedJack, LLC.
 * All rights reserved.
 *
 * Please see the LICENSE.txt file in this distribution for license
 * details.
 * ----------------------------------------------------------------------
 */

#include <assert.h>

#include <libcork/core.h>
#include <libcork/helpers/gc.h>

#include "swanson/kernel.h"
#include "swanson/metamodel.h"


/*-----------------------------------------------------------------------
 * Dynamic opsets
 */

struct swan_explicit_opset {
    struct swan_opset  parent;
    struct swan_opset  *base;
    size_t  instance_size;
    struct swan_operation  alloc;
    struct swan_operation  unref;
};

_evaluate_(swan_explicit, alloc)
{
    struct swan_explicit_opset  *gopset =
        cork_container_of(operation, struct swan_explicit_opset, alloc);

    assert(param_count == 1);
    assert(swan_value_is_empty(&params[0]));
    params[0].content = cork_calloc(1, gopset->instance_size);
    params[0].opset = swan_opset_ref(gopset->base);
    return 0;
}

_evaluate_(swan_explicit, unref)
{
    assert(param_count == 1);
    free(params[0].content);
    swan_opset_unref(params[0].opset);
    swan_value_clear(&params[0]);
    return 0;
}

_get_operation_(swan_explicit)
{
    struct swan_explicit_opset  *gopset =
        cork_container_of(opset, struct swan_explicit_opset, parent);

    if (strcmp(op_name, "~alloc") == 0) {
        return &gopset->alloc;
    } else if (strcmp(op_name, "~unref") == 0) {
        return &gopset->unref;
    } else {
        return swan_opset_get_operation(gopset->base, op_name);
    }
}

static struct swan_opset *
swan_explicit__ref(struct swan_opset *opset)
{
    struct swan_explicit_opset  *gopset =
        cork_container_of(opset, struct swan_explicit_opset, parent);
    return cork_gc_incref(gopset);
}

static void
swan_explicit__unref(struct swan_opset *opset)
{
    struct swan_explicit_opset  *gopset =
        cork_container_of(opset, struct swan_explicit_opset, parent);
    cork_gc_decref(gopset);
}

_free_(swan_explicit_opset) {
    struct swan_explicit_opset  *gopset = obj;
    swan_opset_unref(gopset->base);
}

_gc_no_recurse_(swan_explicit_opset);

struct swan_opset *
swan_explicit_opset_new_from_size(struct swan_opset *base, size_t instance_size)
{
    struct swan_explicit_opset  *gopset = cork_gc_new(swan_explicit_opset);
    gopset->parent.get_operation = swan_explicit__get_operation;
    gopset->parent.ref = swan_explicit__ref;
    gopset->parent.unref = swan_explicit__unref;
    gopset->base = base;
    gopset->instance_size = instance_size;
    gopset->alloc.evaluate = swan_explicit__alloc__eval;
    gopset->unref.evaluate = swan_explicit__unref__eval;
    return &gopset->parent;
}

struct swan_opset *
swan_explicit_opset_new(struct swan_opset *base)
{
    /* TODO: Call an operation to get the instance_size, then delegate to
     * new_from_size */
    return NULL;
}


/*-----------------------------------------------------------------------
 * Helper macros
 */

#define _declare_explicit_opset_(name) \
static struct swan_explicit_opset  _##name##__opset;

#define _explicit_opset_(name, base, instance_size) \
static struct swan_explicit_opset  _##name##__opset = { \
    { \
        swan_explicit__get_operation, \
        swan_opset__static__ref, \
        swan_opset__static__unref \
    }, \
    base, \
    instance_size, \
    { swan_explicit__alloc__eval }, \
    { swan_explicit__unref__eval } \
};

#define explicit_opset(name)  (&_##name##__opset.parent)

#define _public_explicit_opset_(name, base, instance_size) \
_explicit_opset_(name, base, instance_size); \
_opset_accessor_(name, explicit_opset(name));
